#pragma config(Sensor, dgtl1,  topen,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rearArmBotSense, sensorNone)
#pragma config(Sensor, dgtl4,  rearArmTopSense, sensorNone)
#pragma config(Sensor, dgtl7,  armChanger,     sensorNone)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl10, elbowBase,      sensorNone)
#pragma config(Sensor, dgtl11, boten,          sensorQuadEncoder)
#pragma config(Motor,  port3,           clawServo,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           baseMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port9,           elbowMotor,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*******************************************************************************/

void openClaw(){ //open the claw using the servo
	wait1Msec(250);
	motor[clawServo] = 127;
	wait1Msec(250);
}

void closeClaw(){ //close the claw using the servo
	wait1Msec(250);
	motor[clawServo] = -65;
	wait1Msec(250);
}




float forwardKinY(float theta1, float theta2, float l1, float l2){ //forward kinematics to calulate Y position
	float alpha = PI - theta1 - theta2;
	return (l1*sin(theta1)) + (l2 * sin(alpha));
}

float forwardKinX(float theta1, float theta2, float l1, float l2){ //forward kinematics to calulate X position
	float alpha = PI - theta1 - theta2;
	return (l1*cos(theta1)) - (l2 * cos(alpha));
}

float thetaTwo(float x, float y, float l1, float l2) { //Backwards kinematics that calculate theta two
	float answer1 = (x*x)+(y*y)-(l1*l1)-(l2*l2);
	float answer2 = answer1/(2*l1*l2);
	float answer3 = acos(answer2);
	return answer3;
}


float thetaOne(float x, float y, float theta2, float l2) { //Backwards kinematics that calculate theta one
	float answer1 = l2*sin(theta2);
	float answer2 = (x*x)+(y*y);
	float answer3 = sqrt(answer2);
	float answer4 = answer1/answer3;
	float answer5= asin(answer4);
	float answer6 = answer5;
	float answer7 = y/x;
	float answer8 = atan(answer7);
	float answer9 = answer8;
	float answer10 = answer9-answer6;
	return answer10;
}




void baseline(){ //function that returns both arms back into the base position with each arm
								//resting in its limit switch.
		while(SensorValue(armChanger)){
			motor(baseMotor) = 40;
		}
		motor(baseMotor) = 0;
		while(SensorValue(elbowBase)){
			motor(elbowMotor) = -40;
		}
		motor(elbowMotor) = 0;
}



int nextCanX(){ //prompts the sonar to grab the distance to the next can, accounts for distance between sonar and base of the arm
int sonarValue = SensorValue(sonar);
sonarValue = sonarValue + 7;
return sonarValue;
}

//global vars that represent the next goal for the arms to move to. These are set by move and then moved to by movetolocation
float OGoal = 0;
float TGoal = 0;


void move(float x, float y){ // this function set Ogoal and Tgoal it is a mesh of all the math from the 4 kinematics equations
float lowerArm = 36;
float upperArm = 32;
float t2 = thetaTwo(x,y,lowerArm,upperArm);
float t1 = thetaOne(x,y,t2,upperArm);
//these steamlines explain the math and print everything out nicely. they can be comments for the math.
writeDebugStreamLine("these are the values of theta one and theta two that our functions returned");
writeDebugStreamLine("these are probably wrong because it wants to move into the table");
writeDebugStreamLine("Theta One %f", (t1 * 57.3) );
writeDebugStreamLine("Theta Two %f", (t2 * 57.3));
writeDebugStreamLine("---------------------------------");
writeDebugStreamLine("it is ok though we can fix them. First we need to fix theta one ");
writeDebugStreamLine("we can fix theta one by mirroring it over the x axis and then adding");
writeDebugStreamLine("angel formed by the right triangle mde by the x,y pair and the origin");
writeDebugStreamLine("to find that angel we need to take the inverse tangent of y divide by x (soh cah toa)");
float solve1 = y/x;
writeDebugStreamLine("so we take y which is %f", y);
writeDebugStreamLine("and divided by x which is %f", x);
writeDebugStreamLine("which equals %f", solve1);
float solve2 = atan(solve1);
writeDebugStreamLine("now we take the arctangent and get %f", solve2 * 57.3);
float thetaOneGoal  = (solve2* 2)+abs((t1));
writeDebugStreamLine("great now we add the mirror starting answer (abs of theta1)");
writeDebugStreamLine(" and twice the atan angle to get %f", thetaOneGoal * 57.3);
writeDebugStreamLine("----------------------------------");
//This will describe how to fix theta 2.
writeDebugStreamLine("lets fix theta2 now");
writeDebugStreamLine("theta 2 has the same problem it is in the wrong quadrant");
writeDebugStreamLine("all we need to do is flip the sign on theta2 really is that easy :)");
float thetaTwoGoal = t2 * -1;
writeDebugStreamLine("really! its %f", thetaTwoGoal *57.3);
writeDebugStreamLine("lets check our answer with forward Kinematics");
float theY = forwardKinY(thetaOneGoal, thetaTwoGoal, lowerArm, upperArm);
float theX = forwardKinX(thetaOneGoal, thetaTwoGoal, lowerArm, upperArm);
writeDebugStreamLine("checking our x we get %f", theX);
writeDebugStreamLine("checking our y we get %f", theY);
OGoal = thetaOneGoal * 57.3;
TGoal = thetaTwoGoal * 57.3;
}



void moveToLocation(float baseAngle, float elbowAngle){ //simply put the output from the move function which should be stored in global variables
																												// and this function will do the math to calculate how man degrees each arm will need to move.
    SensorValue[boten] = 0; //encoder corresponds to baseAngle
    SensorValue[topen] = 0; //encoder corresponds to elbowAngle
    wait1Msec(1000);
    float needToMoveBotArm = 95 - baseAngle; //this will be the amount of degrees we need to move the base to get to the correct location
    float needToMoveTopArm = 90 + abs(elbowAngle); //this will be the amount of degrees we need to move the arm to get to the correct location
    if((0>needToMoveBotArm) || (needToMoveBotArm > 90) || (needToMoveTopArm < 0) || (needToMoveTopArm > 230)){//conditions for bad movement
    	//this if statement catches an intial out of bounds movement.
    	writeDebugStreamLine("the base motor arm is attempinting to move %f", needToMoveBotArm);
    	writeDebugStreamLine("the elbow motor arm is attempinting to move %f", needToMoveTopArm);
    	writeDebugStreamLine("One of these values is too high or below zero please check the input");
    }
    else{//else nothing has gone wrong and we need to move to the desired location
    	writeDebugStreamLine("Moving elbow motor %f", needToMoveTopArm);
    	while(abs(SensorValue[topen]) < (needToMoveTopArm * 23.497)) {

        motor(elbowMotor) = 50;
    		}
   		motor(elbowMotor) = 0;
   		writeDebugStreamLine("Moving base motor %f", needToMoveBotArm);
    	while(abs(SensorValue[boten]) < (needToMoveBotArm * 4.3)) {
        motor(baseMotor) = -50;
    		}
    		motor(baseMotor) = 0;
  } // after this function everything has been moved to the correct location and the claw should be ready to pick something up
 }



//MAIN FUNCTION
//The main function is 3 things over and over because small adjustments for error need to made each time.
//the formula is baseline->calculate distance->openclaw->move distance->closeclaw->baseline->openclaw->set next can
task main(){
	int canX = nextCanX();

	writeDebugStreamLine("%d", canX);
	wait1Msec(3000);
	baseline();
	move(canX-1, -2);
	writeDebugStreamLine("ThetaOneGoal is: %f", OGoal);
	writeDebugStreamLine("ThetaTwoGoal is: %f", TGoal);
	openClaw();
	wait1Msec(500);
	moveToLocation(OGoal,TGoal);
	wait1Msec(3000);
	closeClaw();
	baseline();
	wait1Msec(500);
	openClaw();
	canX = nextCanX();


	writeDebugStreamLine("%d", canX);
	wait1Msec(3000);
	baseline();
	move(canX+1, -2);
	writeDebugStreamLine("ThetaOneGoal is: %f", OGoal);
	writeDebugStreamLine("ThetaTwoGoal is: %f", TGoal);
	openClaw();
	wait1Msec(500);
	moveToLocation(OGoal,TGoal);
	wait1Msec(3000);
	closeClaw();
	baseline();
	wait1Msec(500);
	openClaw();
	canX = nextCanX();

	writeDebugStreamLine("%d", canX);
	wait1Msec(3000);
	baseline();
	move(canX+1, -2);
	writeDebugStreamLine("ThetaOneGoal is: %f", OGoal);
	writeDebugStreamLine("ThetaTwoGoal is: %f", TGoal);
	openClaw();
	wait1Msec(500);
	moveToLocation(OGoal,TGoal);
	wait1Msec(3000);
	closeClaw();
	baseline();
	wait1Msec(500);
	openClaw();
	canX = nextCanX();
	}
