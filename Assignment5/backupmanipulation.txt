#pragma config(Sensor, dgtl1,  topen,          sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rearArmBotSense, sensorNone)
#pragma config(Sensor, dgtl4,  rearArmTopSense, sensorNone)
#pragma config(Sensor, dgtl5,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl7,  armChanger,     sensorNone)
#pragma config(Sensor, dgtl8,  botMotorButton, sensorNone)
#pragma config(Sensor, dgtl9,  topMotorButton, sensorNone)
#pragma config(Sensor, dgtl10, elbowBase,      sensorNone)
#pragma config(Sensor, dgtl11, boten,          sensorQuadEncoder)
#pragma config(Motor,  port8,           baseMotor,     tmotorVex393, openLoop)
#pragma config(Motor,  port9,           elbowMotor,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*******************************************************************************/

float betaOne = 83; //angle between arm and ground when arm is at base line

void takeDegreesTwo(float deg, int dir) { //base motor
	SensorValue[boten] = 0;
		while(abs(SensorValue[boten]) < (deg*4.3)) {
			if (dir == 0) { //down
				motor(baseMotor) = 120;
			}
			else if (dir == 1) { //up
				motor(baseMotor) = -120;
			}
			else {
				writeDebugStreamLine("Error, will not turn");
			}
		}
	motor(baseMotor) = 0;
}

void takeDegreesThree(float deg, int dir) { //top motor
	SensorValue[topen] = 0;
	while(abs(SensorValue[topen]) < (deg * 16)) { //was previously 23.497
			if (dir == 0) { //down
				motor(elbowMotor) = 50;
			}
			else if (dir == 1) { //up
				motor(elbowMotor) = -50;
			}
			else {
				writeDebugStreamLine("Error, will not turn");
			}
		}
	motor(baseMotor) = 0;
}


float thetaTwo(float x, float y, float l1, float l2) {
	return acos(((x*x)+(y*y)-(l1*l1)-(l2*l2))/(2*l1*l2)) * 57.3;
}

float thetaOne(float x, float y, float theta, float l2) {
	return (atan(y/x) - asin((l2 * sin(theta))/sqrt((x*x) + (y*y)))) * 57.3;
}


float forwardKinY(float theta1, float theta2, float l1, float l2){
	float alpha = 3.14159 - theta1 - theta2;
	return (l1*sinDegrees(theta1)) + (l2 * sinDegrees(alpha));
}

float forwardKinX(float theta1, float theta2, float l1, float l2){
	float alpha = 3.14159 - theta1 - theta2;
	return (l1*cosDegrees(theta1)) - (l2 * cosDegrees(alpha));
}

bool floorCheck(float floor, float theta1, float theta2, float l1, float l2){
	if(forwardKinY(theta1, theta2, l1, l2) <= floor){
		motor[baseMotor] = 0;
		motor[elbowMotor] = 0;
		writeDebugStreamLine("DANGER WILL ROBINSON");
		writeDebugStreamLine("Forward kin of Y %d", forwardKinY(theta1, theta2, l1, l2));
		return true;
	}

	else{
		return false;
	}


}

float shoulderTheta(){ //converts the mesaurement of the shoulder encoder to theta one
	return 180 - (betaOne + (SensorValue[boten] / 4.3));

}

float elbowTheta(){
	return (- SensorValue[topen] / 23.497);

}




void idiotTest(float x, float y){
	float l1 = 37;
	float l2 = 20;
	float theta2 = thetaTwo(x, y, l1, l2);
	float theta1 = thetaOne(x, y, theta2, l2);
	float floor = 5;
	SensorValue[boten] = 0;
	SensorValue[topen] = 0;
	motor[baseMotor] = 0;
	motor[elbowMotor] = 0;
	writeDebugStreamLine("Shoulder theta %d", shoulderTheta());
	writeDebugStreamLine("theta One %d", theta1);
	writeDebugStreamLine("Elbow theta %d", elbowTheta());
	writeDebugStreamLine("theta Two %d", theta2);
	wait10Msec(100);
	while( shoulderTheta() > theta1){
		writeDebugStreamLine("Shoulder theta %d", shoulderTheta());
		writeDebugStreamLine("theta One %d", theta1);
		if(floorCheck(floor, shoulderTheta(), elbowTheta(), l1, l2)){
			break;
		}
		else{
			motor[baseMotor] = -120;
		}
	}
	motor[baseMotor] = 0;
	SensorValue[topen] = 0;
	writeDebugStreamLine("Elbow theta %d", elbowTheta());
	writeDebugStreamLine("theta Two %d", theta2);

	while(elbowTheta() < theta2){
		writeDebugStreamLine("Elbow theta %d", elbowTheta());
		writeDebugStreamLine("theta Two %d", theta2);
		if(floorCheck(floor, shoulderTheta(), elbowTheta(), l1, l2)){
			break;
		}
		else{
			motor[elbowMotor] = 120;
		}
	}


}


void toDestination(float x, float y) {
	float theta1;
	float theta2;
	if(y>5) {
		theta2 = thetaTwo(x,y,37,35);
		theta1 = thetaOne(x,y,theta2,35);
	}
	else {
		theta2 = PI/2;
		theta1 = PI/2;
	}
}

void baseline(){
		while(SensorValue(armChanger) && (SensorValue(botMotorButton) && SensorValue(topMotorButton))){
			motor(baseMotor) = 50;
		}
		motor(baseMotor) = 0;
		while(SensorValue(elbowBase) && (SensorValue(botMotorButton) && SensorValue(topMotorButton))){
			motor(elbowMotor) = -50;
		}
		motor(elbowMotor) = 0;
}

void messwithbuttons(){
	motor(baseMotor) = -50;
	wait1Msec(3000);
	motor(baseMotor) = 0;
	motor(elbowMotor) = 50;
	wait1Msec(3000);
	motor(elbowMotor) = 0;
\
while(true){

	string thing;

		if (!SensorValue(armChanger)) {
				thing = elbowMotor;
		}

		else{
				thing = baseMotor;
		}

		writeDebugStreamLine("Encoder: %d", SensorValue(topen));

		if (!SensorValue(rearArmTopSense)) {
				SensorValue[topen] = 0;
			}
		else if (!SensorValue(rearArmBotSense)) {
			baseline();
		}
		else if ((!SensorValue(botMotorButton)) && (!SensorValue(topMotorButton)) && (!SensorValue(rearArmTopSense))) {
		while(true){
				motor(baseMotor) = 0;
		}
	}

		else if (!SensorValue(botMotorButton)) {
			motor(thing) = 50;
		}
		else if (!SensorValue(topMotorButton)) {
			motor(thing) = -50;
		}
		else {
			motor(thing) = 0;
		}
	}
}

int nextCanX(){
int sonarValue = SensorValue(sonar);
sonarValue = sonarValue + 5;
return sonarValue;
}


//MAIN FUNCTION

task main(){
//motor[baseMotor] = 	-120;
//wait10Msec(50);

baseline();
wait1Msec(2000);
takeDegreesThree(90, 0);
wait1Msec(2000);

//idiotTest(30, 5);


float nextCan;
nextCan = nextCanX();
writeDebugStreamLine("%d", forwardKinY(40, 124, 37, 20));
//	-Move to (x,y) spot but respecting a threshold the entire time as to not crash claw
}